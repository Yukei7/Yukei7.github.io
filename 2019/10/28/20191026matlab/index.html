<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Lecture 1 MATLAB软件入门 1.1 MATLAB特点 MATLAB:MATrix LABoratory，是一种解释性程序语言，无需编译，大都按行逐句解释运行，直到发生错误或中断。">
<meta name="keywords" content="Matlab">
<meta property="og:type" content="article">
<meta property="og:title" content="数学实验与数学软件课件">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;10&#x2F;28&#x2F;20191026matlab&#x2F;index.html">
<meta property="og:site_name" content="Yukei">
<meta property="og:description" content="Lecture 1 MATLAB软件入门 1.1 MATLAB特点 MATLAB:MATrix LABoratory，是一种解释性程序语言，无需编译，大都按行逐句解释运行，直到发生错误或中断。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-10-28T07:50:16.912Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2019/10/28/20191026matlab/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>数学实验与数学软件课件 | Yukei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yukei</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/28/20191026matlab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yukei Yim">
      <meta itemprop="description" content="学数学本是逆天而行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数学实验与数学软件课件
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-10-28 00:21:20 / 修改时间：15:50:16" itemprop="dateCreated datePublished" datetime="2019-10-28T00:21:20+08:00">2019-10-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Maths/" itemprop="url" rel="index">
                    <span itemprop="name">Maths</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="lecture-1-matlab软件入门">Lecture 1 MATLAB软件入门</h2>
<h3 id="matlab特点">1.1 MATLAB特点</h3>
<p>MATLAB:MATrix LABoratory，是一种解释性程序语言，无需编译，大都按行逐句解释运行，直到发生错误或中断。</p>
<a id="more"></a>
<h3 id="变量与特殊数值">1.2 变量与特殊数值</h3>
<p><code>...</code> 是续行输入法</p>
<p>变量名区分大小写，首字母必须为字母，不可与关键词重复</p>
<p><code>realmax('classname')</code> 返回某类型数据的实数最大值，同理 <code>realmin</code></p>
<p><code>intmax('classname'='int32')</code> 返回指定整数类型的最大值，同理 <code>intmin</code></p>
<p><code>eps(2)</code>等价于<span class="math inline">\(2\epsilon\)</span></p>
<h3 id="运算符">1.3 运算符</h3>
<p>A/B 和 A区别： 2/3=0.66，3/2=1.5，在矩阵下定义为 <code>A/B=A*inv(B)</code> 和 <code>A\B=inv(A)*B</code></p>
<p>A<em>B矩阵乘法，A.</em>B矩阵对应位置的乘法，同理A/B和A./B，矩阵乘除法需要满足行列关系否则报错</p>
<h3 id="复数">1.4 复数</h3>
<p><code>i</code> 以及 <code>j</code> 是预留的叙述单位，<code>real()</code> 取实部，<code>imag()</code> 取虚部，<code>angle()</code> 取幅角，可用 <code>abs()</code> 计算复数的模长，<code>conj()</code>计算复数共轭</p>
<p>以上函数均可直接在矩阵上使用，考虑向量化变成提高代码效率。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">z = <span class="number">4</span> + <span class="number">3</span><span class="built_in">i</span></span><br><span class="line">real_z = <span class="built_in">real</span>(z)</span><br><span class="line">image_z = <span class="built_in">imag</span>(z)</span><br><span class="line">magnitude_z = <span class="built_in">abs</span>(z)</span><br><span class="line">angle_z_radian = <span class="built_in">angle</span>(z)</span><br><span class="line">angle_z_degree = <span class="built_in">angle</span>(z)*<span class="number">180</span>/<span class="built_in">pi</span></span><br></pre></td></tr></table></figure>
<p>绘图操作：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">z1=<span class="number">4</span>+<span class="number">3</span><span class="built_in">i</span>;</span><br><span class="line">z2=<span class="number">1</span>+<span class="number">2</span><span class="built_in">i</span>;</span><br><span class="line">z12=z1+z2;</span><br><span class="line">clf</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">0</span>,z1,z12],<span class="string">'-b'</span>,<span class="string">'LineWidth'</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">0</span>,z12],<span class="string">'-r'</span>,<span class="string">'LineWidth'</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>([z1,z12],<span class="string">'ob'</span>,<span class="string">'MarkerSize'</span>,<span class="number">8</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">grid on</span><br><span class="line">axis equal</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>])</span><br><span class="line">text(<span class="number">3.5</span>,<span class="number">2.3</span>,<span class="string">'z1'</span>)</span><br><span class="line">text(<span class="number">5</span>,<span class="number">4.5</span>,<span class="string">'z2'</span>)</span><br><span class="line">text(<span class="number">2.5</span>,<span class="number">3.5</span>,<span class="string">'z12'</span>)</span><br><span class="line">xlabel(<span class="string">'real'</span>)</span><br><span class="line">ylabel(<span class="string">'image'</span>)</span><br></pre></td></tr></table></figure>
<p>复数相关计算，<span class="math inline">\(\sqrt[3]{-8}\)</span>为例</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">-8</span>;</span><br><span class="line">r_a = a^(<span class="number">1</span>/<span class="number">3</span>)<span class="comment">%计算主根</span></span><br><span class="line">r_n = <span class="built_in">nthroot</span>(a,<span class="number">3</span>)<span class="comment">%计算实根</span></span><br><span class="line"></span><br><span class="line">p=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,-a]; <span class="comment">%p(r)=r^3-a的多项式系数</span></span><br><span class="line">R=roots(p) <span class="comment">%返回所有根</span></span><br></pre></td></tr></table></figure>
<h3 id="命令窗功能">1.5 命令窗功能</h3>
<p><code>clf</code> 清空绘图窗口，<code>clc</code> 清空指令窗，<code>clear</code> 清除工作空间变量或<code>clear name</code>清除指定工作变量，<code>close all</code> 关闭所有弹出窗口</p>
<p><code>help name</code> 显示帮助信息，<code>doc name</code> 在浏览器搜索指定内容， <code>helpwin name</code> 弹出窗口显示帮助信息， <code>lookfor name</code> 搜索词条</p>
<p><code>cd</code> 改变目录，<code>dir</code> 当前目录下所有文件，<code>exit</code> 和 <code>quit</code> 退出MATLAB，<code>diary</code> 记录指令窗输入记录</p>
<h2 id="lecture-2-matlab编辑器与符号计算一">Lecture 2 MATLAB编辑器与符号计算（一）</h2>
<h3 id="运算结果显示形式">2.1 运算结果显示形式</h3>
<p><code>format class</code> 恢复预设值，默认为<code>short</code></p>
<p><code>format short (e)/long (e)</code> 5/15位有效数字（科学计数）</p>
<p>其它可选字段有<code>rat</code>近似有理数、<code>hex</code>十六进制、<code>+</code>大矩阵、<code>bank</code>金融，<code>compact</code>紧凑和<code>loose</code>稀疏</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>/<span class="number">3</span>;</span><br><span class="line"><span class="comment">% 默认显示精度为4，实际存储精度为双精度</span></span><br><span class="line">a=<span class="number">0.3333</span></span><br></pre></td></tr></table></figure>
<h3 id="搜索路径原则">2.2 搜索路径原则</h3>
<p>可以在设置搜索路径添加搜索路径，或者可以使用<code>path</code>或<code>addpath</code>命令</p>
<ol type="1">
<li>首先检查内存（工作区），观察cont是否为变量</li>
<li>若不是，检查cont是否为内建函数或常量</li>
<li>在当前文件夹检查是否有名为cont的M文件，若有则需运行对应的M文件（可能为子函数或子程序）</li>
<li>在搜索路径的其他文件夹查找是否有对应的M文件</li>
<li>如果都没有，则会报错</li>
</ol>
<h3 id="符号对象">2.3 符号对象</h3>
<p><code>a = sym(0.3,flag='r')</code>则定义了一个符号变量，具体以<code>3/10</code>存储，<code>flag</code>参数指定存储类型，可选<code>r</code>有理形，<code>d</code>十进制浮点，<code>e</code>机器误差有理格式，<code>f</code>合并的有理形式</p>
<p>字符串小数转换为符号对象会被识别为32位精度的近似小数，计算会有误差。通常先定义符号对象再计算可以减小误差。</p>
<p><code>syms para1 para2 Flag</code>则定义多个符号变量，同在Flag指定域下定义。可选<code>real</code>,<code>positive</code>等</p>
<p><code>syms F(x,y)</code> 则定义符号函数，可以在后续定义具体形式。<code>g(z)=u*w^2+z*w==v</code> 可以定义符号恒等式函数</p>
<p><code>symvar(EXPR)</code> 按字典序显示所有基本符号变量</p>
<p><code>symvar(EXPR,20)</code> 按照ASCII码与’x’距离显示最近的20个</p>
<p><code>disp([‘XXXXX’,str,…])</code>可依次输出多条字符串，非字符串可以用自带变量类型输出，也可用int2str转换，disp此时可等价换为display，多目标输出小括号内中括号不可省略</p>
<h3 id="符号表达式">2.4 符号表达式</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms u v w z <span class="comment">%先定义好基本符号变量</span></span><br><span class="line">Eq=u*w^<span class="number">2</span>+z*w-v <span class="comment">%然后定义符号表达式</span></span><br><span class="line">g(z)=u*w^<span class="number">2</span>+z*w==v <span class="comment">%定义符号恒等式函数</span></span><br></pre></td></tr></table></figure>
<p><code>solve(Eq,var)</code> 缺省变量则默认解的自由变量是x或离x最近的符号</p>
<p><code>vpa(symb,num)</code>将符号对象或传统数化为有指定位数有效数字的结果</p>
<p><code>subs(symb,x,4)</code>将符号对象中指定符号替换为新的对象</p>
<h3 id="符号微积分">2.5 符号微积分</h3>
<p><code>limit(f,x,a,'right')</code> 计算f(x)在x=a处极限，x缺省则为默认变量，a缺省则默认为0，<code>'right'</code>也可选<code>'left'</code>，缺省则为两侧极限。</p>
<p>使用该函数计算左右导数。例如<code>limit((subs(f_p,x,x+d)-f_p)/d,d,0)</code></p>
<p><code>g = diff(f,v,n)</code> 计算f(x)关于v的n阶导数，v缺省则为默认变量，n缺省则为一阶</p>
<p><code>fjac=jacobian(f,v)</code>对矩阵表达式求其雅可比矩阵，f与v需要定义成函数向量与自变量向量，若雅可比矩阵<code>fjac</code>为方阵，可使用<code>detjac=det(fjac)</code>来获得雅可比行列式的抽象表达式（符号型表达式）</p>
<p><code>r=taylor(g,x,a,'Order',10)</code>可获得函数g在x=a点的9阶泰勒展开表达式，x缺省则为默认变量，a缺省则默认为0，不指定阶数则默认为5阶展开。</p>
<p><code>symsum(f,v,a,b)</code> 对f(v)从a到b求级数和</p>
<h2 id="lecture-3-matlab符号计算二">Lecture 3 MATLAB符号计算（二）</h2>
<p><span class="math display">\[(arctan(x))&#39;=\frac{1}{1+x^2}\]</span></p>
<p><span class="math display">\[(arctanh(x))&#39;=\frac{1}{1-x^2}\]</span></p>
<p><span class="math display">\[(arcsin(x))&#39;=\frac{1}{\sqrt{1+x^2}}\]</span></p>
<p><span class="math display">\[(arcsinh(x))&#39;=\frac{1}{\sqrt{1-x^2}}\]</span></p>
<h3 id="符号对象的识别">3.1 符号对象的识别</h3>
<p><code>size()</code>返回矩阵行列数</p>
<p><code>class()</code>显示变量类型</p>
<p><code>isa(matrix,'char')</code>返回1或0，确定输入是否具有指定数据类型</p>
<p><code>whos para1 para2</code>列表显示所有内存变量类别</p>
<h3 id="符号转双精度或符号型小数">3.2 符号转双精度或符号型小数</h3>
<p><code>reset(symengine)</code> 符号运算设置重置</p>
<p><code>vpa(x,n)</code> 对x截取n位有效数字（仍是sym），n缺省则按当前digits位数</p>
<p><code>digit(n)</code> 设置vpa截断位数n，可以用<code>digit</code>显示当前截断位数</p>
<p><code>eval(x)</code> sym型转化成命令计算双精度结果</p>
<h3 id="符号表达式的基本操作">3.3 符号表达式的基本操作</h3>
<p><code>collect(equation, variable)</code> 合并同类项</p>
<p><code>expand(equation)</code> 多项式展开</p>
<p><code>simplify(equation)</code>简化函数符号表达式，可选参数<code>step</code>调整简化步数。使用时注意有时需要设置<code>'IgnoreAnalyticConstraints',true</code> 忽视复数根</p>
<p><code>[N,D]=numden(equation)</code> (Numerator and denominator of a symbolic expression)通分为分子N和分母D</p>
<p><code>pretty(equation)</code> 美化（并不美观）</p>
<p><code>[r,s]=subexpr(equation)</code> 提取公子式（<span class="math inline">\(r(s)\)</span>=equation）</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 特征向量分解</span></span><br><span class="line">syms a b c d</span><br><span class="line">A = [a b;c d];</span><br><span class="line">[V,D] = eig(A);</span><br><span class="line">[RVD,w] = subexpr([V;D])</span><br></pre></td></tr></table></figure>
<p><code>subs(eqation,old,new)</code> variable可以由<code>tuple</code>输入完成批量代换，对应返回高维数组，数据类型相同时可以由<code>vector</code>输入</p>
<p><code>int(function,variable,lower,upper)</code> 符号函数计算定积分，上下限缺省时为不定积分</p>
<p><code>h1 = fplot(x(t),y(t),t_range)</code> 例如t_range=[0,2*pi]传入上下界的向量，h1是<strong>绘图句柄</strong>，可以用<code>set(h1,'Color','r','LineWidth',5)</code>设置绘图具体参数</p>
<p><code>h1 = ezplot(y(1),[x_range,y_range])</code></p>
<h3 id="微分方程组的符号解法">3.4 微分方程组的符号解法</h3>
<p>声明符号变量时需要指明是符号函数<code>syms x y(x)</code></p>
<p><code>S=dsolve([eq1,eq2],condition)</code>常微分方程理论解，返回解可能有常数C1,C2等。具体每一个解可以通过<span class="math inline">\(S.name\)</span>得到。在对常数进行赋值时，可以借助<code>symvar(S)</code>来获得对应的常数符号。</p>
<h3 id="傅里叶变换">3.5 傅里叶变换</h3>
<p>进行时频分析，决定信号在什么频率上更强。</p>
<p><span class="math display">\[F(\omega)=\int_{-\infty}^{+\infty} f(t)e^{-j\omega t}dt\]</span></p>
<p>逆变换定义</p>
<p><span class="math display">\[f(t)=\frac{1}{2\pi}\int_{-\infty}^{+\infty}F(\omega)e^{j\omega t}d\omega\]</span></p>
<p>Dirac function</p>
<p>在<span class="math inline">\(\omega\not ={0}\)</span>处<span class="math inline">\(F(\omega)\equiv 0\)</span>，而在<span class="math inline">\(\omega=0\)</span>处“无穷大”</p>
<p><span class="math display">\[\delta(x)=\lim_{a\rightarrow 0^+}\frac{1}{a\sqrt{\pi}}e^{\frac{-x^2}{a^2}}\]</span></p>
<p><code>fourier(function,time,w)</code> 时间域到频率域</p>
<p><code>ifourier(function,w,time)</code> 频率域到时间域</p>
<h4 id="傅里叶变换的一些性质">傅里叶变换的一些性质</h4>
<p><span class="math display">\[F(\omega)=\int_{-\infty}^{+\infty}f(t)e^{-j\omega t}dt\]</span></p>
<p><strong>平移性质:</strong></p>
<p>对于有平移混淆的信号（信号相似，有时间差），可以借助傅里叶变换平移性质，即模相等的性质取消平易混淆 <span class="math display">\[|\mathscr{L}(f(t-t_0))|=|\mathscr{L}(f(t))|\]</span></p>
<p><strong>导数性质:</strong></p>
<p><span class="math display">\[\mathscr{L}(f&#39;(t))=i\omega F(\omega)\]</span></p>
<p>其中<span class="math inline">\(\mathscr{L}(f(t))=F(\omega)\)</span></p>
<p><strong>卷积性质:</strong></p>
<p>傅里叶变换下对卷积计算的复杂性降低（从<span class="math inline">\(O(n^4)\)</span>到<span class="math inline">\(O(n^2logn)\)</span>），用于解决反卷积问题</p>
<h2 id="lecture-4-matlab符号计算三">Lecture 4 MATLAB符号计算（三）</h2>
<h3 id="matlab的符号限制性假设">4.1 MATLAB的符号限制性假设</h3>
<p>在使用<code>sym</code>或<code>syms</code>定义符号变量时，MATLAB启动MuPAD引擎并提供内存工作空间执行符号运算。若不带限定性假设，默认为复数。</p>
<p><code>syms a positive</code> 定义正实数变量</p>
<p><code>assume(a,'positive')</code> 对已定义符号变量更改限制性假设，也可以添加表达式的限制性假设如<code>assume(imag(x)==0)</code>等形式</p>
<p><code>assumptions(x)</code> 查看变量x当前的限定性假设</p>
<p><code>clear all</code> 或 <code>syms a clears</code> 清除全部或符号变量a的限制性假设</p>
<p><code>assumeAlso()</code> 对符号变量增加限制性假设（不覆盖原有假设）</p>
<h3 id="laplace变换">4.2 Laplace变换</h3>
<p><span class="math display">\[F(s)=\int_0^{\infty}f(t)e^{-st}dt\]</span></p>
<p>逆变换</p>
<p><span class="math display">\[f(t)=\frac{1}{2\pi j}\int_{c-j\infty}^{c+j\infty}F(s)e^{st}ds\]</span></p>
<p><code>laplace(ft,time,w)</code> 从时间域到频率域</p>
<p><code>ilaplace(Fs,w,time)</code> 从频率域到时间域</p>
<h3 id="z变换">4.3 Z变换</h3>
<p><span class="math display">\[F(z)=\sum_{n=0}^\infty f(n)z^{-n}\]</span></p>
<p>逆变换</p>
<p><span class="math display">\[f(n)=\frac{1}{2\pi j}\oint_\Gamma F(z)z^{n-1}dz\]</span></p>
<p>Z变换描述离散序列的复数频率域信息，可以把差分方程转化为代数方程。</p>
<p><code>ztrans(fn,time,z)</code> 从时间域到频率域</p>
<p><code>iztrans(FZ,z,time)</code> 从频率域到时间域</p>
<h3 id="符号卷积">4.4 符号卷积</h3>
<p><span class="math display">\[(u*h)(t)=\int_0^t u(\tau)h(t-\tau)d\tau\]</span></p>
<p>可以通过Laplace变换和逆变换的性质快速求出：</p>
<p><span class="math display">\[(u*h)(t)=\mathscr{L}^{-1}(\mathscr{L}(u(t))·\mathscr{L}(h(t)))\]</span></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clear all</span><br><span class="line">syms T t tao s</span><br><span class="line">ut=<span class="built_in">exp</span>(-t);ht=<span class="built_in">exp</span>(-t/T)/T;</span><br><span class="line">uh_tao=subs(ut,t,tao)*subs(ht,t,t-tao);</span><br><span class="line"><span class="comment">% 直接法</span></span><br><span class="line">yt1=int(uh_tao,tao,<span class="number">0</span>,t)</span><br><span class="line"><span class="comment">% 间接法</span></span><br><span class="line">yt21=ilaplace(laplace(ut,t,s)*laplace(ht,t,s),s,t)</span><br><span class="line">yt22=collect(yt21,(T<span class="number">-1</span>))<span class="comment">%合并同类项</span></span><br></pre></td></tr></table></figure>
<h3 id="符号矩阵分析与计算数值矩阵">4.5 符号矩阵分析与计算（数值矩阵）</h3>
<p><code>det(A)</code> 求行列式</p>
<p><code>diag(A)</code> 取A对角元或利用向量形成对角矩阵</p>
<p><code>expm(A)</code> 计算A的指数矩阵，需要将A特征值取指数复原</p>
<p><code>inv(A)</code> 求逆矩阵</p>
<p><code>rank(A)</code> 求A的秩</p>
<p><code>tril(A)</code> 化A为下三角矩阵，也有<code>triu(A)</code>化为上三角矩阵</p>
<p><code>[V D] = eig(A)</code> 计算A的特征值保存到D，特征向量保存到V</p>
<p><code>[V J] = jordan(A)</code> 计算A的Jordan分解，AV=VJ</p>
<p><code>[U S V] = svd(A)</code> 计算A的奇异值分解，A=USV'</p>
<p><code>[L U] = lu(A)</code> 计算A的LU分解，A=LU</p>
<p><code>[Q R] = qr(A)</code> 计算A的QR分解，A=QR</p>
<h3 id="一般方程组符号解">4.6 一般方程组符号解</h3>
<p><code>[v1,v2,..] = solve(exp1,exp2,..,v1,v2,..)</code> 对任何代数方程组的符号解</p>
<h3 id="符号计算结果可视化">4.7 符号计算结果可视化</h3>
<ul>
<li><code>ezcountour(fun)</code> 画等位线</li>
<li><code>ezcontourf(fun)</code> 画填色等位线</li>
<li><code>ezplot(fun,[xmin,xmax])</code> 二维曲线绘图，可接受参数方程：<code>ezplot(funx,funy,[tmin,tmax])</code></li>
<li><code>ezplot3(funx,funy,funz,[tmin,tmax])</code> 三维曲线绘图</li>
<li><code>ezpolar(fun,[a,b])</code> 极坐标曲线</li>
<li><code>ezsurf(funx,funy,funz,[smin,smax,tmin,tmax])</code> 空间曲面图，也可以对<span class="math inline">\(z=z(x,y),a&lt;x&lt;b,c&lt;y&lt;d\)</span>的形式：<code>ezsurf(z(x,y),[a,b,c,d])</code>以及<span class="math inline">\(z=z(x,y),a&lt;x,y&lt;b\)</span>的形式：<code>ezsurf(z(x,y),[a,b])</code></li>
<li><code>ezsurfc(funx,funy,funz,[smin,smax,tmin,tmax])</code> 带等位线的曲面图</li>
<li><code>ezmesh(funx,funy,funz,[smin,smax,tmin,tmax])</code> 三维网格绘图函数，用法同<code>ezsurf()</code></li>
<li><code>ezmeshc(funx,funy,funz,[smin,smax,tmin,tmax])</code> 带等位线的网格图，用法同<code>ezsurfc()</code></li>
</ul>
<p><strong>积分互补性质：</strong> Week4 PPT 39</p>
<h2 id="lecture-5-matlab数值数组与数组化编程">Lecture 5 MATLAB数值数组与数组化编程</h2>
<h3 id="一维数组向量">5.1 一维数组（向量）</h3>
<p><code>A = start:step:end</code> 创建行向量，while(start&lt;end): 添加start, start+=step</p>
<p><code>linspace(start,end,n)</code>创建一位数组，等价于<code>start:(end-start)/(n-1):end</code></p>
<p>（步长为实数时，近似值向零取整，可以确保得到希望的步数，例如0:pi/4:pi一定能得到4个值）</p>
<p><code>logspace(a,b,n)</code>创建等比数列，也即<code>10.^linspace(a,b,n)</code>，等价于<code>10.^(a:(b-a)/(n-1):b)</code></p>
<p><code>ones(1,n)</code>生成1行n列的全为1的行向量，<code>one(n)</code>生成元素全为1的n阶方阵</p>
<p><code>zeros(1,n), rand(1,n), randn(1,n)</code>生成全为零，0-1均匀分布随机，标准正态分布随机的行向量</p>
<p><code>rng default</code>使随机状态回复到Matlab初始值（伪随机）</p>
<p><code>A.'</code>转置，<code>conj(A)</code>共轭，<code>A'</code>共轭转置</p>
<p><code>ndims(A)</code>矩阵维数，<code>size(A,nd)</code>矩阵第nd维的规模（缺省nd则返回每一维的大小，类似<code>shape</code>）</p>
<p><code>length(A)</code>矩阵最大维度规模（或向量长度）</p>
<p><code>numel(A)</code>矩阵所含元素的总数目</p>
<h3 id="矩阵二维数组">5.2 矩阵（二维数组）</h3>
<p><code>load A</code> 读取当前文件夹下A.mat的矩阵</p>
<p><code>ones(m,n), zeros(m,n), rand(m,n), randn(m,n)</code>常用<code>zeros(m,n)</code>申请存储空间，缺省一维则生成方阵</p>
<p><code>eye(n)</code>生成单位方阵</p>
<p><code>magic(n)</code>生成n阶幻方（行列和相等）</p>
<p><code>diag(A)</code>A为方阵：提取方阵对角元为列向量 / A为1维向量：利用向量生成对角阵</p>
<p><code>random(gm,n), randsrc(m,n,[set;prob]), gallery(name)</code>一般随机数字矩阵、指定字符集随机数组、特殊功能的测试数组</p>
<p><code>rng(seed)</code> 设置随机种子</p>
<p><code>speye(n)</code> 生成稀疏的n阶单位矩阵</p>
<p><code>B=sparse(A)</code>正常定义的矩阵转化为稀疏矩阵（由三元组方式进行定义）</p>
<p><code>reshape(A,m,n)</code>将矩阵A变形成m行n列的矩阵，matlab中矩阵存储可以理解为列优先的数组</p>
<p><code>repmat(A,m,n)</code> 按行数复制m份，列数复制n份</p>
<p><code>flipud(A), fliplr(A)</code> 上下、左右对称翻转</p>
<p><code>rot90(A,n)</code> 矩阵A逆时针旋转n*90度</p>
<h3 id="二维数组编址">5.3 二维数组编址</h3>
<p><code>A(r,c)</code> 全下标编址，可以计算<code>A(i,j)=A((j-1)*M+i), j=ceil(k/M), i=k-(j-1)*M, A(k)=A(i,j)</code>，其中r和c可以接受向量。</p>
<p>计算时只需注意矩阵是列优先，按列存储的。</p>
<p><code>A(ind)</code>访问ind包含的元素，得到规模与ind相同的向量，<code>A(:)</code>默认为列向量（ind类似定义为r=[2,3]，或L=A&lt;=0逻辑方式索引）</p>
<p>注：A([1,end])是传入ind为[1,end]的两个单序号寻址，对应矩阵数组第一个和最后一个值</p>
<p><code>[rowsub, colsub] = ind2sub([M N],IND)</code>得到IND对应的行列指标</p>
<p><code>IND = sub2ind([M N], rowsub, colsub)</code>得到单序号IND</p>
<h3 id="数组的运算">5.4 数组的运算</h3>
<p>矩阵运算可以减少for循环，但使用时需要注意是矩阵乘除法还是数组乘除法。</p>
<p><code>bsxfun(@fun,A,B)</code> 对矩阵A和B使用fun</p>
<p><code>all(vector)</code> 返回0或1，是否全部非零</p>
<p><code>any(vector)</code> 返回0或1，是否存在非零</p>
<p>注：对向量t用逻辑方法Lt = (t==0)会得到一个逻辑向量，常用于判断是否满足条件并进行定位操作</p>
<p><code>ceil()</code> 向<span class="math inline">\(+\infty\)</span>取整</p>
<p><code>fix()</code> 向0取整</p>
<p><code>floor()</code> 向<span class="math inline">\(-\infty\)</span>取整</p>
<p><code>mod()</code> 取模，<code>rem()</code> 取余，x和y的符号不同时，rem函数结果的符号和x的一样，而mod和y一样。这是由于这两个函数的生成机制不同，rem函数采用fix函数，而mod函数采用了floor函数</p>
<p><code>round()</code> 四舍五入</p>
<p><code>sign()</code> 返回1或-1或0，符号函数</p>
<p><code>[azimuth,elevation,r] = cart2sph(x,y,z)</code> 直角坐标转球坐标，反向有<code>sph2cart()</code></p>
<p><code>[theta,rho] = cart2pol(x,y)</code> 直角坐标转极坐标，反向有<code>pol2cart()</code></p>
<p><code>[theta,rho,z] = cart2pol(x,y,z)</code> 直角坐标转柱坐标，反向有<code>pol2cart()</code></p>
<h2 id="lecture-6-matlab矩阵函数与程序设计初步">Lecture 6 MATLAB矩阵函数与程序设计初步</h2>
<h3 id="矩阵的乘除运算">6.1 矩阵的乘除运算</h3>
<p><code>A*B</code>要求满足矩阵乘法的行列要求</p>
<p><code>A\B=inv(A)*B</code>或<code>A/B=A*inv(B)</code>可以解线性方程组<span class="math inline">\(Ax=b\)</span>也就是<code>x=A\b</code>，矩阵方程<span class="math inline">\(XA=B\)</span>可以用<code>X=B/A</code>来解出。超定方程（A列满秩）可以提供最小二乘解</p>
<p>关于数组运算，<span class="math inline">\(&lt;C^S,+,.∗&gt;\)</span>构成复数集合<span class="math inline">\(\mathscr{C}^S\)</span>上的数组域</p>
<p>关于矩阵运算，<span class="math inline">\(&lt;C^{M\times N},+&gt;\)</span>构成复数集合<span class="math inline">\(\mathscr{C}^{(M\times N)}\)</span>上的阿贝尔群</p>
<h3 id="矩阵的幂运算与矩阵函数">6.2 矩阵的幂运算与矩阵函数</h3>
<p>若<span class="math inline">\(A=Q·diag(\lambda_1,...,\lambda_n)·Q^{-1}\)</span>且特征值各异：</p>
<p><code>b^A</code>为<span class="math inline">\(Q·diag(b^{\lambda_1},..,b^{\lambda_n})·Q^{-1}\)</span></p>
<p><code>A^b</code>为<span class="math inline">\(Q·diag(\lambda_1^{b},..,\lambda_n^{b})·Q^{-1}\)</span></p>
<p><code>expm(A)</code>为矩阵指数函数<span class="math inline">\(Q·diag(e^{\lambda_1},...,e^{\lambda_n})·Q^{-1}\)</span></p>
<p><code>logm(A)</code>为矩阵对数函数<span class="math inline">\(Q·diag(\ln \lambda_1,...,\ln \lambda_n)·Q^{-1}\)</span></p>
<p><code>sqrtm(A)</code>为矩阵平方根函数<span class="math inline">\(Q·diag(\sqrt{\lambda_1},...,\sqrt{\lambda_n})·Q^{-1}\)</span></p>
<p><code>funm(A,Hfun)</code>为矩阵函数<span class="math inline">\(Q·diag(f(\lambda_1),...,f(\lambda_n))·Q^{-1}\)</span>，Hfun为函数句柄</p>
<h3 id="matlab控制流">6.3 MATLAB控制流</h3>
<p><code>if-elseif-else-end</code> end不可缺省</p>
<p><code>switch-case value-otherwise-end</code> value常用胞元数组</p>
<p><code>for-end</code>以及<code>while-end</code>循环</p>
<p><code>break</code>和<code>continue</code>同C++，死循环时可以在命令行用Ctrl+C停止运行</p>
<p><code>pause</code>程序在该行暂停，可以用<code>pause(n)</code>暂停n秒。<code>keyboard</code>进入调试模式，键入<code>dbcont</code>恢复代码段的运行</p>
<p><code>a = input('input a number')</code> 屏幕输出，并将输入值赋给a</p>
<p><code>return</code>结束当前函数并返回上一级函数，若在主程序中则程序运行结束</p>
<p><code>a = inputdlg('input a number)</code> 弹窗输入，返回值是胞元。另外有<code>listdlg</code>和<code>questdlg</code>进行列表和多选弹窗。</p>
<p><code>fminbnd(fx,a,b)</code>可以计算某个区间内的一个极小值，对于波动较大的函数，极小值不一定是最小值</p>
<p><a href="#倍增区间极值搜索法">倍增区间极值搜索法</a>，将分割区间的长度不断变小，从而可以获得“更多的极小值”，每一次分割都将获取最小的一个极小值。在单调区间个数有限的假设下，分割越细，就越有可能获得最小值。</p>
<p>最终当进一步分层后，获取的最小值在连续几次倍增后不变（或变化量极小），就退出循环，结束区间倍增，然后输出最终得到的最小值、最小值点以及最终倍增区间的个数。</p>
<h3 id="胞元">6.4 胞元</h3>
<p><code>B(1,2)</code> 援引，返回内容标签 如[3x3 double]</p>
<p><code>B{1,2}</code> 内容援引，返回具体内容</p>
<h2 id="lecture-7-matlab数值微积分">Lecture 7 MATLAB数值微积分</h2>
<h3 id="差分方法">7.1 差分方法</h3>
<p><code>dx = diff(X)</code> 为向量或矩阵的向前差分运算，等价于<code>dx = X(2:n,:) - X(1:n-1,:)</code>，结果比X少一行</p>
<p><code>FX = gradient(F)</code> 为向量或矩阵的中心差分运算，等价于<code>FX(1)=F(2)-F(1),FX(end)=F(end)-F(end-1),FX(2:end-1)=0.5*(F(3:end)-F(1:end-2))</code>，结果与F长度相同。矩阵的一元梯度仅包括横向</p>
<p><code>[FX,FY] = gradient(F)</code>二元梯度运算，FX为横向梯度（每一行右减左），FY为纵向梯度（每一列下减上）</p>
<p>注：用realmin近似计算函数极限时，若分子分母都趋于<span class="math inline">\(\epsilon\)</span>且阶数较高时，MATLAB不能正常返回结果而是会生成NaN。近似导数计算时步长太小会出现毛刺现象。</p>
<h3 id="数值求和与累积和">7.2 数值求和与累积和</h3>
<p><code>sum(X,dim)</code> 矩阵求和，dim默认为1即按列方向求和，返回行向量</p>
<p><code>Scs = cumsum(X)</code> 矩阵按列方向求累积和，返回同型矩阵</p>
<h3 id="数值积分">7.3 数值积分</h3>
<p>将定积分<span class="math inline">\(\int_a^bf(x)dx\)</span>积分区间划分为<span class="math inline">\(a=x_0&lt;x_1&lt;x_2&lt;...&lt;x_n=b\)</span>，对每一个节点分段<span class="math inline">\([x_i,x_{i+1}]\)</span>，分段积分<span class="math inline">\(\int_{x_i}^{x_{i+1}}f(x)dx\)</span>的近似</p>
<h4 id="中矩形公式">中矩形公式</h4>
<p><span class="math display">\[\int_{x_i}^{x_{i+1}}f(x)dx\approx f(\frac{x_i+x_{i+1}}{2})(x_{i+1}-x_i)\]</span></p>
<h4 id="复合梯形公式">复合梯形公式</h4>
<p><span class="math display">\[\int_{x_i}^{x_{i+1}}f(x)dx\approx \frac{f(x_i)+f(x_{i+1})}{2}(x_{i+1}-x_i)\]</span></p>
<p><code>trapz(y)</code> 使用梯形公式方法对函数矩阵y按列方向求和，首尾元素求和时乘以权值0.5</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="built_in">pi</span>/<span class="number">8</span>; t = <span class="number">0</span>:d:<span class="built_in">pi</span>/<span class="number">2</span>; y=<span class="number">0.2</span>+<span class="built_in">sin</span>(t);</span><br><span class="line">s_ta = d*trapz(y);</span><br></pre></td></tr></table></figure>
<p><code>trap(x,y)</code> 函数矩阵y按列方向求关于x的和，x为函数采样序列y对应的自变量列表，可以接受非均匀采样。</p>
<p><code>cumtrapz(y)</code> 函数矩阵累积式按列方向求和，返回同型矩阵</p>
<p><code>cumtrapz(x,y)</code> 函数矩阵累积式按列方向求和，x为指定自变量列表</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Y = [<span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span>];</span><br><span class="line">Q = cumtrapz(Y);</span><br><span class="line"><span class="comment">%Q = 1×5</span></span><br><span class="line"><span class="comment">%         0    2.5000    9.0000   21.5000   42.0000</span></span><br></pre></td></tr></table></figure>
<h4 id="辛普森公式">辛普森公式</h4>
<p><span class="math display">\[\int_{x_i}^{x_{i+1}}f(x)dx\approx \frac{f(x_i)+4f(\frac{x_i+x_{i+1}}{2})+f(x_{i+1})}{6}(x_{i+1}-x_i)\]</span></p>
<h4 id="monte-carlo法">Monte Carlo法</h4>
<p><span class="math display">\[\int_{x_i}^{x_{i+1}}f(x)dx\approx \frac{\sum_{j=1}^Kf(x_{i,j})}{K}(x_{i+1}-x_i)\]</span></p>
<p>其中<span class="math inline">\(\forall 1\leq j\leq K,x_{i,j}\in [x_i,x_{i+1}]\)</span>为子区间随机采样点，一般用均匀分布。</p>
<p>Monte Carlo法除去计算数值积分外，也可以用于估计某些实数的值。例如<span class="math inline">\(\sqrt{2}\)</span>可以通过在<span class="math inline">\(X\sim U[0,2]\)</span>上多次取样本值，计算<span class="math inline">\(x^2\leq 2\)</span>的占比，理论值为<span class="math inline">\(\frac{\sqrt{2}}{2}\)</span></p>
<h3 id="匿名函数">7.4 匿名函数</h3>
<p><code>F = @(var) sin(var).*var</code> 一句话函数，F为函数句柄，括号内为参数</p>
<h3 id="内建数值积分函数">7.5 内建数值积分函数</h3>
<p><code>Q = integral(fun,xmin,xmax)</code> 匿名函数句柄以及积分上下限。可选参数<code>'AbsTol'</code>控制绝对误差（注意需要调小<code>'RelTol'</code>保证精度） <code>'ArrayValued'</code>被积函数是否为阵列函数，<code>'Waypoints'</code>指定积分路径</p>
<h2 id="lecture-8-matlab微分方程数值解法">Lecture 8 MATLAB微分方程数值解法</h2>
<h3 id="差分方程">8.1 差分方程</h3>
<p>利用固定间隔的函数值构成的递推关系称为差分方程。</p>
<p><span class="math display">\[f(x)=F(f(x-1),f(x-2),...,f(x-n))\]</span></p>
<p>常系数线性差分方程的形式如下</p>
<p><span class="math display">\[f(x)=a_1f(x-1)+a_2f(x-2)+...+a_nf(x-n)+g(x)\]</span></p>
<p>若<span class="math inline">\(g(x)\equiv 0\)</span>则为常系数齐次线性差分方程，解法如下：</p>
<p><span class="math display">\[f(x)=a_1f(x-1)+a_2f(x-2)+...+a_nf(x-n)\]</span></p>
<p>解其特征方程<span class="math inline">\(\lambda^n-a_1\lambda^{n-1}-a_2\lambda^{n-2}-...-a_{n-1}\lambda-a_n=0\)</span></p>
<p>若得到n个两两不同的实特征根<span class="math inline">\(\lambda_1&lt;\lambda_2&lt;...&lt;\lambda_n\)</span>，则差分方程的通解为 <span class="math display">\[f(x)=c_1\lambda_1^x+c_2\lambda_2^x+...+c_n\lambda_n^x\]</span></p>
<h3 id="差分方程与微分方程">8.2 差分方程与微分方程</h3>
<p>差分方程<span class="math inline">\(f(x+d)=(1+d)·f(x)\)</span>等价于</p>
<p><span class="math display">\[f(x+d)-f(x)=d·f(x)\]</span></p>
<p>则当<span class="math inline">\(d\leftarrow 0\)</span>时，问题等价于微分方程</p>
<p><span class="math display">\[f&#39;(x)=\lim_{d\rightarrow 0}\frac{f(x+d)-f(x)}{d}=f(x)\]</span></p>
<p><strong>结论：</strong> 小步长差分方程是微分方程的数值近似。</p>
<p><span class="math display">\[f(x+d)=(1+d)·f(x)=f(x)+d·f(x)\]</span></p>
<p>就是<span class="math inline">\(f&#39;(x)=f(x)\)</span>的一种简单的数值近似求解方法</p>
<h3 id="欧拉法">8.3 欧拉法</h3>
<p>假设微分方程为<span class="math inline">\(y&#39;(x)=f(x,y(x))\)</span>，初值条件<span class="math inline">\(y(x_0)=y^*\)</span></p>
<p>则从初值条件<span class="math inline">\(y_0=f(x_0)=y^*\)</span>开始逐步迭代</p>
<p><span class="math display">\[y_{n+1}=y_n+d·y&#39;(x_n) = y_n+d·f(x_n,y_n)\]</span></p>
<h3 id="改进欧拉法">8.4 改进欧拉法</h3>
<p>假设微分方程为<span class="math inline">\(y&#39;(x)=f(x,y(x))\)</span>，初值条件<span class="math inline">\(y(x_0)=y^*\)</span></p>
<p>改进的欧拉法对每一步迭代所导入的导数值进行预估和矫正：</p>
<p><span class="math display">\[
\begin{cases}
    \overline{y_{n+1}}=y_n+d\cdot f(x_n,y_n)\\
    y_{n+1}=y_n+\frac{d}{2}\cdot [f(x_n,y_n)+f(x_{n+1},\overline{y_{n+1}})]
\end{cases}
\]</span></p>
<p>改进欧拉法同样也可以解一阶的微分方程组，只需要将未知函与导函数看成向量<span class="math inline">\(\vec{y}&#39;(x)=\vec{f}(x,\vec{y}(x))=\vec{f}(x,y_1(x),y_2(x),...,y_n(x)),\vec{y}(x_0)=\vec{y^*}\)</span></p>
<h3 id="龙格-库塔法">8.5 龙格-库塔法</h3>
<p>假设微分方程为<span class="math inline">\(y&#39;(x)=f(x,y(x))\)</span>，初值条件<span class="math inline">\(y(x_0)=y^*\)</span></p>
<p>使用不同的增量位置代入并加权平均<span class="math inline">\(\sum_{i=1}^nc_i=1\)</span></p>
<p><span class="math display">\[y_{n+1}=y_n+d\cdot \sum_{i=1}^rc_if(x_n,\lambda_id,y(x_n+\lambda_id))\]</span></p>
<p>二阶龙格-库塔法的中点公式</p>
<p><span class="math display">\[y_{n+1}=y_n+d\cdot f(x_n+\frac{d}{2},y_n+\frac{d}{2}f(x_n,y_n))\]</span></p>
<h3 id="一阶微分方程组演化实例见ppt">8.6 一阶微分方程组演化实例（见PPT）</h3>
<p>设矩阵<span class="math inline">\(A\)</span>有实特征值<span class="math inline">\(\lambda_1,\lambda_2\)</span>，并假设<span class="math inline">\(A\)</span>有两个线性无关的特征向量<span class="math inline">\(v_1,v_2\)</span>.过原点按<span class="math inline">\(v_1,v_2\)</span>方向做直线，即构成了两条演化轨迹（trajectory）的渐近线。若特征值<span class="math inline">\(\lambda&gt;0\)</span>，则在对应的特征向量方向上趋于无穷；若特征值<span class="math inline">\(\lambda=0\)</span>，则在对应方向上不作位移（静止不动或平行于另一条渐近线移动）；若特征值<span class="math inline">\(\lambda&lt;0\)</span>，则在对应方向趋于原点。</p>
<h3 id="高阶微分方程">8.7 高阶微分方程</h3>
<p><code>[t,y] = ode45(odefun,tspan,y0)</code> 4阶龙格库塔法，t和y返回时间与函数序列，odefun为导函数句柄，tspan为数值解法的时间区间，y0为初值列向量</p>
<p>高阶微分方程可以转化成一阶微分方程组。</p>
<h2 id="附录">附录</h2>
<h3 id="倍增区间极值搜索法">倍增区间极值搜索法</h3>
<p><code>fminbnd(fx,a,b)</code>可以计算某个区间内的一个极小值，对于波动较大的函数，极小值不一定是最小值</p>
<p>倍增区间极值搜索法，将分割区间的长度不断变小，从而可以获得“更多的极小值”，每一次分割都将获取最小的一个极小值。在单调区间个数有限的假设下，分割越细，就越有可能获得最小值。</p>
<p>最终当进一步分层后，获取的最小值在连续几次倍增后不变（或变化量极小），就退出循环，结束区间倍增，然后输出最终得到的最小值、最小值点以及最终倍增区间的个数。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[xmin,fmin,n]</span>=<span class="title">exm060101</span><span class="params">(fx,a,b,Nt)</span></span></span><br><span class="line"><span class="comment">%fx为函数,a,b为左右端点，Nt为子区间细分的过程中极小值点重复超过多少次即可停止细分</span></span><br><span class="line"><span class="comment">%xmin和ymin代表最小值所在的横坐标和纵坐标，n为获得最小值时分割的子区间数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%求fx在(a,b)一个极小值，f0记录最小值，第一个返回值（最小值点）舍去</span></span><br><span class="line">[~,f0]=fminbnd(fx,a,b);</span><br><span class="line">n=<span class="number">1</span>;<span class="comment">%初始区间没有分割，共1个区间</span></span><br><span class="line">jj=<span class="number">1</span>;<span class="comment">%同一最小值的重复出现次数</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> <span class="comment">%无限的循环（需要带有条件的break跳出循环）</span></span><br><span class="line">n=<span class="number">2</span>*n;<span class="comment">%循环区间数X2</span></span><br><span class="line">d=(b-a)/n;<span class="comment">%区间长度/2</span></span><br><span class="line">    x=a:d:b;</span><br><span class="line">ii=<span class="number">0</span>;<span class="comment">%本轮循环（本次精度）极小值的数量</span></span><br><span class="line">xc=<span class="built_in">zeros</span>(<span class="number">1</span>,n);fc=xc;<span class="comment">%本次循环极值点与极值的点的数组</span></span><br><span class="line">    <span class="keyword">for</span> k=<span class="number">1</span>:n<span class="comment">%</span></span><br><span class="line">        [w,f,eflag]=fminbnd(fx,x(k),x(k+<span class="number">1</span>));</span><br><span class="line">        <span class="comment">%子区间取极值点，w为点，f为值，flag为是否找到</span></span><br><span class="line">        <span class="keyword">if</span> eflag&gt;<span class="number">0</span></span><br><span class="line">            ii=ii+<span class="number">1</span>;<span class="comment">%极小值数量+1</span></span><br><span class="line">            xc(ii)=w;</span><br><span class="line">            fc(ii)=f;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xc = xc(<span class="number">1</span>:ii);fc = fc(<span class="number">1</span>:ii);</span><br><span class="line">    [fmin,kk]=<span class="built_in">min</span>(fc);<span class="comment">%最小值fmin，位置kk</span></span><br><span class="line">    xmin=xc(kk);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(f0-fmin)&lt;<span class="number">1e-6</span> <span class="comment">%足够小的最小值</span></span><br><span class="line">        jj=jj+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> jj&gt;Nt</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> f0-fmin&gt;<span class="number">1e-6</span></span><br><span class="line">        f0=fmin;<span class="comment">%确立新最小值</span></span><br><span class="line">        jj=<span class="number">1</span>;<span class="comment">%reset重复次数</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="hilbert矩阵的创建">Hilbert矩阵的创建</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">1000</span> <span class="comment">%阶数</span></span><br><span class="line">n = <span class="built_in">repmat</span>(<span class="number">1</span>:N,N,<span class="number">1</span>);</span><br><span class="line">m = n';</span><br><span class="line">A = <span class="number">1.</span>/(n+m<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Matlab/" rel="tag"># Matlab</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/10/30/20191030regression/" rel="prev" title="应用回归分析">
                  应用回归分析 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-1-matlab软件入门"><span class="nav-number">1.</span> <span class="nav-text">Lecture 1 MATLAB软件入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#matlab特点"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 MATLAB特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量与特殊数值"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 变量与特殊数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复数"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 复数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令窗功能"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 命令窗功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-2-matlab编辑器与符号计算一"><span class="nav-number">2.</span> <span class="nav-text">Lecture 2 MATLAB编辑器与符号计算（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运算结果显示形式"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 运算结果显示形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索路径原则"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 搜索路径原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号对象"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 符号对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号表达式"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 符号表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号微积分"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 符号微积分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-3-matlab符号计算二"><span class="nav-number">3.</span> <span class="nav-text">Lecture 3 MATLAB符号计算（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#符号对象的识别"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 符号对象的识别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号转双精度或符号型小数"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 符号转双精度或符号型小数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号表达式的基本操作"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 符号表达式的基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微分方程组的符号解法"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 微分方程组的符号解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#傅里叶变换"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 傅里叶变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#傅里叶变换的一些性质"><span class="nav-number">3.5.1.</span> <span class="nav-text">傅里叶变换的一些性质</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-4-matlab符号计算三"><span class="nav-number">4.</span> <span class="nav-text">Lecture 4 MATLAB符号计算（三）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#matlab的符号限制性假设"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 MATLAB的符号限制性假设</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#laplace变换"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 Laplace变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#z变换"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 Z变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号卷积"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 符号卷积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号矩阵分析与计算数值矩阵"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 符号矩阵分析与计算（数值矩阵）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一般方程组符号解"><span class="nav-number">4.6.</span> <span class="nav-text">4.6 一般方程组符号解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号计算结果可视化"><span class="nav-number">4.7.</span> <span class="nav-text">4.7 符号计算结果可视化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-5-matlab数值数组与数组化编程"><span class="nav-number">5.</span> <span class="nav-text">Lecture 5 MATLAB数值数组与数组化编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一维数组向量"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 一维数组（向量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵二维数组"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 矩阵（二维数组）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二维数组编址"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 二维数组编址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的运算"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 数组的运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-6-matlab矩阵函数与程序设计初步"><span class="nav-number">6.</span> <span class="nav-text">Lecture 6 MATLAB矩阵函数与程序设计初步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵的乘除运算"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 矩阵的乘除运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵的幂运算与矩阵函数"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 矩阵的幂运算与矩阵函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#matlab控制流"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 MATLAB控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#胞元"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 胞元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-7-matlab数值微积分"><span class="nav-number">7.</span> <span class="nav-text">Lecture 7 MATLAB数值微积分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#差分方法"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 差分方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值求和与累积和"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 数值求和与累积和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值积分"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 数值积分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中矩形公式"><span class="nav-number">7.3.1.</span> <span class="nav-text">中矩形公式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复合梯形公式"><span class="nav-number">7.3.2.</span> <span class="nav-text">复合梯形公式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#辛普森公式"><span class="nav-number">7.3.3.</span> <span class="nav-text">辛普森公式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#monte-carlo法"><span class="nav-number">7.3.4.</span> <span class="nav-text">Monte Carlo法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名函数"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 匿名函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内建数值积分函数"><span class="nav-number">7.5.</span> <span class="nav-text">7.5 内建数值积分函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-8-matlab微分方程数值解法"><span class="nav-number">8.</span> <span class="nav-text">Lecture 8 MATLAB微分方程数值解法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#差分方程"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 差分方程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#差分方程与微分方程"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 差分方程与微分方程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#欧拉法"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 欧拉法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改进欧拉法"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 改进欧拉法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#龙格-库塔法"><span class="nav-number">8.5.</span> <span class="nav-text">8.5 龙格-库塔法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一阶微分方程组演化实例见ppt"><span class="nav-number">8.6.</span> <span class="nav-text">8.6 一阶微分方程组演化实例（见PPT）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高阶微分方程"><span class="nav-number">8.7.</span> <span class="nav-text">8.7 高阶微分方程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-number">9.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#倍增区间极值搜索法"><span class="nav-number">9.1.</span> <span class="nav-text">倍增区间极值搜索法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hilbert矩阵的创建"><span class="nav-number">9.2.</span> <span class="nav-text">Hilbert矩阵的创建</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Yukei Yim"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Yukei Yim</p>
  <div class="site-description" itemprop="description">学数学本是逆天而行</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yukei Yim</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
